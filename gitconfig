[user]
	name = Jimmy Durand Wesolowski
[color]
	ui = auto
[alias]
	lg = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --date=relative
	lgo = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%ai) %C(bold blue)<%an>%Creset' --abbrev-commit
	logs = log --stat
	rmlist = !git status --porcelain | grep -E \"^[A ]D\" | cut -c 4-
	rmdel = !git rm $(git rmlist)

	# From http://stackoverflow.com/questions/171550/find-out-which-remote-\
	#branch-a-local-branch-is-tracking and https://git.wiki.kernel.org/\
	#index.php/Aliases
        out = !LOCAL_BRANCH=$(git name-rev --name-only HEAD) && \
	    TRACKING_REMOTE=$(git config branch.$LOCAL_BRANCH.remote) && \
	    git log $TRACKING_REMOTE/$LOCAL_BRANCH..HEAD \
		--pretty='format:%Cred%h%Creset %s' --color
        subm = submodule
        serve = daemon --reuseaddr --verbose  --base-path=. --export-all ./.git
        stp = status .
        dif = diff --no-ext-diff
        ncdiff = diff -I"/*/" -I"//*\n"
        ss = show --stat
	st = status

	# From https://git.wiki.kernel.org/index.php/Aliases - Improved
	# When you want to see just the differences of one function in one file
	# in two different commits, you can do this:
	# Usage: git funcdiff <old-rev> <new-rev> <path> <function>
	funcdiff = "!f() { git show \"$0:$2\" | \
			sed -n \"/^[^ \t].*$3[ \t]*(/,/^}/p\" > .tmp1 &&\
		git show \"$1:$2\" | \
			sed -n \"/^[^ \t].*$3[ \t]*(/,/^}/p\" > .tmp2 &&\
		git diff --no-index .tmp1 .tmp2 }; f"

        edit-unmerged = "!f() { git ls-files --unmerged | cut -f2 |	\
		sort -u ; }; ${EDITOR} `f`"
        add-unmerged = "!f() { git ls-files --unmerged | cut -f2 |	\
		sort -u ; }; git add `f`"

	# Retrieve hash list
	hash-list = log --oneline --pretty='format:%h'

	# Diff search
	# Usage: git ds [directory or file to search]
	ds = "!f() {							\
		for hash in $(git hash-list $1); do			\
			git show ${hash} ${1};				\
			echo -n 'Next (Y)?';				\
			read ans;					\
			if [ \"$ans\" != \"y\" -a \"$ans\" != \"\" ]; then \
				break;					\
			fi;						\
		done;							\
	 }; f"

	# Find git commit altering a regex given in argument, in the
	# optional directory argument
	find = "!f() {							\
		if [ -z ${1} ]; then					\
			echo 'argument required: <pattern> [search path]';\
			exit 1;						\
		fi;							\
		for hash in $(git hash-list -- ${2}); do		\
			diff=$(git show ${hash} -- ${2} |		\
				grep -C 2 --color=always ${1});		\
			if [ -n \"${diff}\" ]; then			\
				PAGER= git log --oneline -n 1 ${hash};	\
				echo \"${diff}\";			\
				echo;					\
			fi;						\
		done;							\
	}; f $*"

	# Reversed log
	up = "!f() {							\
		BRANCH=master;						\
		if [ -n $1 ]; then					\
			BRANCH=$1;					\
		fi;							\
		git log --reverse --ancestry-path HEAD~..$BRANCH	\
			--pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset';\
	}; f"

	# Usage: git signoff-rebase [base-commit]
	# Source: http://stackoverflow.com/questions/25570947/how-to-use-git-interactive-rebase-for-signing-off-a-series-of-commits
	signoff-rebase = "!GIT_SEQUENCE_EDITOR='sed -i -re s/^pick/e/' sh -c 'git rebase -i $1 && while git rebase --continue; do git commit --amend --signoff --no-edit; done' -"
	signoff-check = "!PAGER=; f() {					\
		HASHES=$(git log --pretty=format:'%h' $@);		\
		NAME='Jimmy Durand Wesolowski';				\
		for hash in ${HASHES}; do				\
			MATCH=$(git show --format=format:%B ${hash} |	\
				grep \"Signed-off-by: ${NAME}\");	\
			if [ -n \"${MATCH}\" ]; then			\
				msg='%Cgreen(V)%Creset';		\
			else						\
				msg='%Cred(X)%Creset';			\
			fi;						\
			git log -1 --pretty=tformat:\"%Cred%h%Creset -%C(yellow)%d%Creset %s ${msg}\"\
				${hash};				\
		done;							\
	}; f"

	bc = "!f() {							\
		git diff --name-only \"$@\" | while read filename; do	\
			git difftool -x bcompare \"$@\" -y ${filename} &\
		done;							\
	}; f"

	commit = commit -s
	co = checkout
	br = branch
	ci = commit
	unstage = reset HEAD --
	last = log -1 HEAD

	# Checkout out and reset files
	resetnco = "!usage() {						\
			echo 'Usage: resetnco <file> [file [file ...]]';\
		}; 							\
		f() {							\
			if [ $# -lt 1 ]; then usage; exit 1; fi;	\
			git reset $* && git checkout $*;		\
		}; f"

[merge]
	tool = meld
[credential]
	helper = cache --timeout=36000
