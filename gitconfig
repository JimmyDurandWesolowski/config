[user]
	name = Jimmy Durand Wesolowski
[color]
	ui = auto
[alias]
	lg = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --date=relative
	lgo = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%ai) %C(bold blue)<%an>%Creset' --abbrev-commit
	logs = log --stat
	rmlist = !git status --porcelain | grep -E \"^[A ]D\" | cut -c 4-
	rmdel = !git rm $(git rmlist)
	# From http://stackoverflow.com/questions/171550/find-out-which-remote-branch-a-local-branch-is-tracking and https://git.wiki.kernel.org/index.php/Aliases
        out = !LOCAL_BRANCH=$(git name-rev --name-only HEAD) && TRACKING_REMOTE=$(git config branch.$LOCAL_BRANCH.remote) && git log $TRACKING_REMOTE/$LOCAL_BRANCH..HEAD --pretty='format:%Cred%h%Creset %s' --color
	st = status
        subm = submodule
        serve = daemon --reuseaddr --verbose  --base-path=. --export-all ./.git
        stp = status .
        dif = diff --no-ext-diff
        ncdiff = diff -I"/*/" -I"//*\n"
        ss = show --stat

	# From https://git.wiki.kernel.org/index.php/Aliases - Improved
	# When you want to see just the differences of one function in one file
	# in two different commits, you can do this:
	# Usage: git funcdiff <old-rev> <new-rev> <path> <function>
	funcdiff = "!f() { git show \"$0:$2\" | \
			sed -n \"/^[^ \t].*$3[ \t]*(/,/^}/p\" > .tmp1 &&\
		git show \"$1:$2\" | \
			sed -n \"/^[^ \t].*$3[ \t]*(/,/^}/p\" > .tmp2 &&\
		git diff --no-index .tmp1 .tmp2 }; f"

        edit-unmerged = "!f() { git ls-files --unmerged | cut -f2 |	\
		sort -u ; }; ${EDITOR} `f`"
        add-unmerged = "!f() { git ls-files --unmerged | cut -f2 |	\
		sort -u ; }; git add `f`"

	# Retrieve hash list
	hash-list = log --oneline --pretty='format:%h'

	# Diff search
	# Usage: git ds [directory or file to search]
	ds = "!f() {							\
		for hash in $(git hash-list $1); do			\
			git show ${hash} ${1};				\
			echo -n 'Next (Y)?';				\
			read ans;					\
			if [ \"$ans\" != \"y\" -a \"$ans\" != \"\" ]; then \
				break;					\
			fi;						\
		done; };						\
		f"

	# Find modificaton with a regex, into an optional directory
	find = "!PAGER= sh -c 'if [ -z ${1} ]; then echo \"argument required: <pattern> [search path]\"; exit 1; fi; for hash in $(git hash-list -- ${2}); do diff=$(git show ${hash} -- ${2} | grep -C 2 --color=always ${1}); if [ -n \"${diff}\" ]; then git log --oneline -n 1 ${hash}; echo \"${diff}\"; echo; fi; done' -"
	up = "!f() { BRANCH=master; if [ -n $1 ]; then BRANCH=$1; fi; git log --reverse --ancestry-path HEAD~..$BRANCH --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset'; }; f"
	# Usage: git signoff-rebase [base-commit]
	# Source: http://stackoverflow.com/questions/25570947/how-to-use-git-interactive-rebase-for-signing-off-a-series-of-commits
	signoff-rebase = "!GIT_SEQUENCE_EDITOR='sed -i -re s/^pick/e/' sh -c 'git rebase -i $1 && while git rebase --continue; do git commit --amend --signoff --no-edit; done' -"
	signoff-check = "!PAGER=; f() { HASHES=$(git log --pretty=format:'%h' $@); for hash in ${HASHES}; do git log -1 --pretty=tformat:\"%Cred%h%Creset -%C(yellow)%d%Creset %s $(if [ -n \"$(git show ${hash} | grep 'Signed-off-by: Jimmy Durand Wesolowski')\" ]; then echo '%Cgreen(V)%Creset'; else echo '%Cred(X)%Creset'; fi)\" ${hash}; done; }; f"
	commit = commit -s
	co = checkout
	br = branch
	ci = commit
	unstage = reset HEAD --
	last = log -1 HEAD

[merge]
	tool = meld

[credential]
	helper = cache --timeout=36000
